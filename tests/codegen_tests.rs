use shard::{generate, parse, tokenize};

#[test]
fn test_codegen_simple_assignment() {
    let tokens = tokenize("x = 10").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("#!/bin/sh"));
    assert!(output.contains("__shard_x=10"));
}

#[test]
fn test_codegen_string_assignment() {
    let tokens = tokenize("name = 'Shard'").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_name='Shard'"));
}

#[test]
fn test_codegen_boolean_true() {
    let tokens = tokenize("flag = true").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_flag=true"));
}

#[test]
fn test_codegen_boolean_false() {
    let tokens = tokenize("flag = false").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_flag=false"));
}

#[test]
fn test_codegen_null() {
    let tokens = tokenize("val = null").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_val=null"));
}

#[test]
fn test_codegen_simple_command() {
    let tokens = tokenize("echo hello").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_stdout_tmp=$(mktemp)"));
    assert!(output.contains("__shard_stderr_tmp=$(mktemp)"));
    assert!(output.contains("echo \"$__shard_hello\""));
    assert!(output.contains("__shard_status=$?"));
    assert!(output.contains("rm -f \"$__shard_stdout_tmp\" \"$__shard_stderr_tmp\""));
}

#[test]
fn test_codegen_command_with_multiple_args() {
    let tokens = tokenize("ls -la /home").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    eprintln!("Generated output:\n{}", output);

    assert!(output.contains("ls"));
    assert!(output.contains("-la"));
    assert!(output.contains("/home"));
}

#[test]
fn test_codegen_command_no_args() {
    let tokens = tokenize("clear").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("clear >"));
}

#[test]
fn test_codegen_multiple_assignments() {
    let tokens = tokenize("x = 1\ny = 2\nz = 3").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_x=1"));
    assert!(output.contains("__shard_y=2"));
    assert!(output.contains("__shard_z=3"));
}

#[test]
fn test_codegen_mixed_statements() {
    let tokens = tokenize("name = 'test'\necho name\nprint 42").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    eprintln!("Generated output:\n{}", output);

    assert!(output.contains("__shard_name='test'"));
    assert!(output.contains("echo \"$__shard_name\""));
    // 42 is an integer literal, so it's output as-is (not quoted)
    assert!(output.contains("print 42") || output.contains("print \"42\""));
}

#[test]
fn test_codegen_variable_prefixing() {
    let tokens = tokenize("my_var = 10").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_my_var=10"));
}

#[test]
fn test_codegen_temp_file_cleanup() {
    let tokens = tokenize("echo test").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("rm -f \"$__shard_stdout_tmp\" \"$__shard_stderr_tmp\""));
}

#[test]
fn test_codegen_stdout_capture() {
    let tokens = tokenize("echo test").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_stdout=$(cat < \"$__shard_stdout_tmp\")"));
}

#[test]
fn test_codegen_stderr_capture() {
    let tokens = tokenize("echo test").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_stderr=$(cat < \"$__shard_stderr_tmp\")"));
}

#[test]
fn test_codegen_exit_status_capture() {
    let tokens = tokenize("echo test").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard_status=$?"));
}

#[test]
fn test_codegen_full_pipeline() {
    let input = "name = 'Shard'\necho 'Hello' name";
    let tokens = tokenize(input).unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    // Verify the complete generated script structure
    assert!(output.starts_with("#!/bin/sh\n# Generated by Shard\n\n"));
    assert!(output.contains("__shard_name='Shard'"));
    assert!(output.contains("echo 'Hello' \"$__shard_name\""));
    assert!(output.contains("__shard_status=$?"));
}

#[test]
fn test_codegen_empty_program() {
    let tokens = tokenize("").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("#!/bin/sh"));
    assert!(!output.contains("__shard_")); // No variables or commands
}

#[test]
fn test_codegen_underscore_variable() {
    let tokens = tokenize("_private = 42").unwrap();
    let ast = parse(tokens).unwrap();
    let output = generate(&ast).unwrap();

    assert!(output.contains("__shard__private=42"));
}
