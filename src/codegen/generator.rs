use crate::ast::{Expression, Literal, Program, Statement};
use crate::codegen::error::CodegenResult;

pub fn generate(program: &Program) -> CodegenResult<String> {
    let mut output = String::new();

    output.push_str("#!/bin/sh\n");
    output.push_str("# Generated by Shard\n\n");

    for statement in &program.0 {
        generate_statement(&mut output, statement)?;
        output.push('\n');
    }

    Ok(output)
}

fn generate_statement(output: &mut String, statement: &Statement) -> CodegenResult<()> {
    match statement {
        Statement::Assignment { name, value } => {
            let var_name = format!("__shard_{}", name);
            let var_value = generate_expression(value)?;
            output.push_str(&format!("{}={}\n", var_name, var_value));
        }
        Statement::Command { name, args } => {
            generate_command(output, name, args)?;
        }
    }
    Ok(())
}

fn generate_expression(expr: &Expression) -> CodegenResult<String> {
    match expr {
        Expression::Literal(literal) => match literal {
            Literal::Integer(n) => Ok(n.to_string()),
            Literal::Boolean(true) => Ok("true".to_string()),
            Literal::Boolean(false) => Ok("false".to_string()),
            Literal::Null => Ok("null".to_string()),
            Literal::String(s) => Ok(format!("'{}'", s)),
        },
        Expression::Identifier(name) => Ok(format!("\"$__shard_{}\"", name)),
    }
}

fn generate_command(output: &mut String, name: &str, args: &[Expression]) -> CodegenResult<()> {
    let args_str: Vec<String> = args
        .iter()
        .map(generate_expression)
        .collect::<Result<Vec<_>, _>>()?;

    output.push_str("__shard_stdout_tmp=$(mktemp)\n");
    output.push_str("__shard_stderr_tmp=$(mktemp)\n");

    let cmd_line = if args_str.is_empty() {
        name.to_string()
    } else {
        format!("{} {}", name, args_str.join(" "))
    };

    output.push_str(&format!(
        "{} > \"$__shard_stdout_tmp\" 2> \"$__shard_stderr_tmp\"\n",
        cmd_line
    ));
    output.push_str("__shard_status=$?\n");
    output.push_str("__shard_stdout=$(cat < \"$__shard_stdout_tmp\")\n");
    output.push_str("__shard_stderr=$(cat < \"$__shard_stderr_tmp\")\n");
    output.push_str("rm -f \"$__shard_stdout_tmp\" \"$__shard_stderr_tmp\"\n");

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::tokenize;
    use crate::parser::parse;

    #[test]
    fn test_generate_assignment() {
        let tokens = tokenize("x = 10").unwrap();
        let ast = parse(tokens).unwrap();
        let result = generate(&ast).unwrap();
        assert!(result.contains("__shard_x=10"));
    }

    #[test]
    fn test_generate_command() {
        let tokens = tokenize("echo hello").unwrap();
        let ast = parse(tokens).unwrap();
        let result = generate(&ast).unwrap();
        assert!(result.contains("__shard_stdout_tmp=$(mktemp)"));
        assert!(result.contains("__shard_status=$?"));
    }
}
