use crate::ast::{Expression, Literal, Program, Statement};
use crate::codegen::error::CodegenResult;

pub fn generate(program: &Program) -> CodegenResult<String> {
    let mut output = String::new();

    output.push_str("#!/bin/sh\n");
    output.push_str("# Generated by Shard\n\n");

    for statement in &program.0 {
        generate_statement(&mut output, statement)?;
        output.push('\n');
    }

    Ok(output)
}

fn generate_statement(output: &mut String, statement: &Statement) -> CodegenResult<()> {
    match statement {
        Statement::Assignment { name, value } => {
            let var_name = format!("__shard_{}", name);
            let var_value = generate_expression(value)?;
            output.push_str(&format!("{}={}\n", var_name, var_value));
        }
        Statement::Command { name, args } => {
            generate_command(output, name, args)?;
        }
        Statement::If {
            condition,
            then_branch,
            else_branch,
        } => {
            let cond_str = generate_expression(condition)?;
            // If condition is already a test expression [ ... ], use it directly
            // Otherwise wrap it in [ ]
            if cond_str.starts_with('[') && cond_str.ends_with(']') {
                output.push_str(&format!("if {}; then\n", cond_str));
            } else {
                output.push_str(&format!("if [ {} ]; then\n", cond_str));
            }
            for stmt in then_branch {
                generate_statement(output, stmt)?;
                output.push('\n');
            }
            if let Some(else_body) = else_branch {
                output.push_str("else\n");
                for stmt in else_body {
                    generate_statement(output, stmt)?;
                    output.push('\n');
                }
            }
            output.push_str("fi\n");
        }
        Statement::While { condition, body } => {
            let cond_str = generate_expression(condition)?;
            // If condition is already a test expression [ ... ], use it directly
            if cond_str.starts_with('[') && cond_str.ends_with(']') {
                output.push_str(&format!("while {}; do\n", cond_str));
            } else {
                output.push_str(&format!("while [ {} ]; do\n", cond_str));
            }
            for stmt in body {
                generate_statement(output, stmt)?;
                output.push('\n');
            }
            output.push_str("done\n");
        }
        Statement::For {
            variable,
            iterable,
            body,
        } => {
            // Check if iterable is an array literal
            let iter_str = match iterable {
                Expression::Literal(Literal::Array(elements)) => {
                    let elems: Result<Vec<String>, _> =
                        elements.iter().map(|e| generate_expression(e)).collect();
                    elems?.join(" ")
                }
                _ => {
                    let iter = generate_expression(iterable)?;
                    // Remove parentheses if present
                    iter.trim_start_matches('(')
                        .trim_end_matches(')')
                        .to_string()
                }
            };
            output.push_str(&format!("for __shard_{} in {}; do\n", variable, iter_str));
            for stmt in body {
                generate_statement(output, stmt)?;
                output.push('\n');
            }
            output.push_str("done\n");
        }
        Statement::FunctionDef {
            name,
            params,
            body,
            return_value: _,
        } => {
            output.push_str(&format!("{}() {{\n", name));
            for stmt in body {
                generate_statement(output, stmt)?;
                output.push('\n');
            }
            output.push_str("}\n");
        }
        Statement::Return { value } => {
            if let Some(expr) = value {
                let val_str = generate_expression(expr)?;
                output.push_str(&format!("return {}\n", val_str));
            } else {
                output.push_str("return\n");
            }
        }
        Statement::Try {
            body,
            catch_var: _,
            catch_body,
        } => {
            output.push_str("if true; then\n");
            for stmt in body {
                generate_statement(output, stmt)?;
                output.push('\n');
            }
            output.push_str("else\n");
            for stmt in catch_body {
                generate_statement(output, stmt)?;
                output.push('\n');
            }
            output.push_str("fi\n");
        }
        Statement::Break => {
            output.push_str("break\n");
        }
        Statement::Continue => {
            output.push_str("continue\n");
        }
        Statement::ExpressionStatement(expr) => {
            let expr_str = generate_expression(expr)?;
            output.push_str(&format!("{}\n", expr_str));
        }
    }
    Ok(())
}

fn generate_expression(expr: &Expression) -> CodegenResult<String> {
    match expr {
        Expression::Literal(literal) => match literal {
            Literal::Integer(n) => Ok(n.to_string()),
            Literal::Float(f) => Ok(f.to_string()),
            Literal::Boolean(true) => Ok("true".to_string()),
            Literal::Boolean(false) => Ok("false".to_string()),
            Literal::Null => Ok("null".to_string()),
            Literal::String(s) => Ok(format!("'{}'", s)),
            Literal::Array(elements) => {
                let elements_str: Vec<String> = elements
                    .iter()
                    .map(|e| generate_expression(e))
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(format!("({})", elements_str.join(" ")))
            }
            Literal::Map(pairs) => {
                let pairs_str: Vec<String> = pairs
                    .iter()
                    .map(|(k, v)| {
                        let k_str = generate_expression(k)?;
                        let v_str = generate_expression(v)?;
                        Ok(format!("{}={}", k_str, v_str))
                    })
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(format!("({})", pairs_str.join(" ")))
            }
        },
        Expression::Identifier(name) => Ok(format!("\"$__shard_{}\"", name)),
        Expression::BinaryOp { op, left, right } => {
            let left_str = generate_expression(left)?;
            let right_str = generate_expression(right)?;

            // For comparison operators used in conditions, use test syntax
            let is_comparison = matches!(
                op,
                crate::ast::BinaryOperator::Equals
                    | crate::ast::BinaryOperator::NotEquals
                    | crate::ast::BinaryOperator::Less
                    | crate::ast::BinaryOperator::Greater
                    | crate::ast::BinaryOperator::LessEquals
                    | crate::ast::BinaryOperator::GreaterEquals
            );

            if is_comparison {
                let shell_op = match op {
                    crate::ast::BinaryOperator::Equals => "-eq",
                    crate::ast::BinaryOperator::NotEquals => "-ne",
                    crate::ast::BinaryOperator::Less => "-lt",
                    crate::ast::BinaryOperator::Greater => "-gt",
                    crate::ast::BinaryOperator::LessEquals => "-le",
                    crate::ast::BinaryOperator::GreaterEquals => "-ge",
                    _ => unreachable!(),
                };
                // Remove quotes from identifiers for test command
                let left_clean = left_str.trim_matches('"').to_string();
                let right_clean = right_str.trim_matches('"').to_string();
                Ok(format!("[ {} {} {} ]", left_clean, shell_op, right_clean))
            } else {
                let shell_op = match op {
                    crate::ast::BinaryOperator::Add => "+",
                    crate::ast::BinaryOperator::Subtract => "-",
                    crate::ast::BinaryOperator::Multiply => "*",
                    crate::ast::BinaryOperator::Divide => "/",
                    crate::ast::BinaryOperator::Modulo => "%",
                    crate::ast::BinaryOperator::And => "&&",
                    crate::ast::BinaryOperator::Or => "||",
                    _ => unreachable!(),
                };
                // For arithmetic, strip quotes from variable references
                let left_clean = left_str.trim_matches('"').to_string();
                let right_clean = right_str.trim_matches('"').to_string();
                Ok(format!("$(({} {} {}))", left_clean, shell_op, right_clean))
            }
        }
        Expression::UnaryOp { op, expr } => {
            let expr_str = generate_expression(expr)?;
            match op {
                crate::ast::UnaryOperator::Negate => Ok(format!("$((-{}))", expr_str)),
                crate::ast::UnaryOperator::Not => Ok(format!("!{}", expr_str)),
            }
        }
        Expression::ArrayIndex { array, index } => {
            let arr_str = generate_expression(array)?;
            let idx_str = generate_expression(index)?;
            Ok(format!("${{{}{}}}", arr_str, idx_str))
        }
        Expression::MapIndex { map, key } => {
            let map_str = generate_expression(map)?;
            let key_str = generate_expression(key)?;
            Ok(format!("${{{}{}}}", map_str, key_str))
        }
        Expression::FunctionCall { name, args } => {
            let args_str: Vec<String> = args
                .iter()
                .map(|a| generate_expression(a))
                .collect::<Result<Vec<_>, _>>()?;
            match name.as_str() {
                "len" if args.len() == 1 => Ok(format!("${{#{}}}", args_str[0])),
                _ => Ok(format!("$({} {})", name, args_str.join(" "))),
            }
        }
        Expression::InterpolatedString { parts } => {
            let parts_str: Vec<String> = parts
                .iter()
                .map(|p| generate_expression(p))
                .collect::<Result<Vec<_>, _>>()?;
            Ok(format!("\"{}\"", parts_str.join("")))
        }
        Expression::Range { start, end } => {
            let start_str = generate_expression(start)?;
            let end_str = generate_expression(end)?;
            Ok(format!("$(({}-{}))", start_str, end_str))
        }
        Expression::Length { expr } => {
            let expr_str = generate_expression(expr)?;
            Ok(format!("${{#{}}}", expr_str))
        }
    }
}

fn generate_command(output: &mut String, name: &str, args: &[Expression]) -> CodegenResult<()> {
    let args_str: Vec<String> = args
        .iter()
        .map(|arg| generate_expression(arg))
        .collect::<Result<Vec<_>, _>>()?;

    output.push_str("__shard_stdout_tmp=$(mktemp)\n");
    output.push_str("__shard_stderr_tmp=$(mktemp)\n");

    let cmd_line = if args_str.is_empty() {
        format!("{}", name)
    } else {
        format!("{} {}", name, args_str.join(" "))
    };

    output.push_str(&format!(
        "{} > \"$__shard_stdout_tmp\" 2> \"$__shard_stderr_tmp\"\n",
        cmd_line
    ));
    output.push_str("__shard_status=$?\n");
    output.push_str("__shard_stdout=$(cat < \"$__shard_stdout_tmp\")\n");
    output.push_str("__shard_stderr=$(cat < \"$__shard_stderr_tmp\")\n");
    output.push_str("rm -f \"$__shard_stdout_tmp\" \"$__shard_stderr_tmp\"\n");

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::tokenize;
    use crate::parser::parse;

    #[test]
    fn test_generate_assignment() {
        let tokens = tokenize("x = 10").unwrap();
        let ast = parse(tokens).unwrap();
        let result = generate(&ast).unwrap();
        assert!(result.contains("__shard_x=10"));
    }

    #[test]
    fn test_generate_command() {
        let tokens = tokenize("echo hello").unwrap();
        let ast = parse(tokens).unwrap();
        let result = generate(&ast).unwrap();
        assert!(result.contains("__shard_stdout_tmp=$(mktemp)"));
        assert!(result.contains("__shard_status=$?"));
    }

    #[test]
    fn test_generate_multiple_assignments() {
        let tokens = tokenize("x = 1\ny = 2\nz = 3").unwrap();
        let ast = parse(tokens).unwrap();
        let result = generate(&ast).unwrap();
        assert!(result.contains("__shard_x=1"));
        assert!(result.contains("__shard_y=2"));
        assert!(result.contains("__shard_z=3"));
    }

    #[test]
    fn test_generate_empty_program() {
        let tokens = tokenize("").unwrap();
        let ast = parse(tokens).unwrap();
        let result = generate(&ast).unwrap();
        assert!(result.contains("#!/bin/sh"));
    }
}
